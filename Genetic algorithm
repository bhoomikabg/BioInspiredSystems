#import random

# --- Fitness Function (minimize distance) ---
def fitness(path, dist_matrix):
    total = 0
    for i in range(len(path)):
        total += dist_matrix[path[i]][path[(i+1) % len(path)]]
    # Since GA works better with maximization, return negative distance
    return -total  

# --- Order Crossover (OX) ---
def crossover(p1, p2, point1, point2):
    size = len(p1)
    child = [None] * size
    # Copy slice from p1
    child[point1:point2] = p1[point1:point2]
    # Fill remaining with order from p2
    pos = point2
    for city in p2:
        if city not in child:
            if pos == size: pos = 0
            child[pos] = city
            pos += 1
    return child

# --- Swap Mutation ---
def mutate(path, i, j):
    path = path[:]
    path[i], path[j] = path[j], path[i]
    return path

# --- User Input ---
n = int(input("Enter number of cities: "))
dist_matrix = []
print("Enter distance matrix:")
for _ in range(n):
    dist_matrix.append(list(map(int, input().split())))

pop_size = int(input("Enter population size: "))
population = []
for _ in range(pop_size):
    path = list(range(n))
    random.shuffle(path)
    population.append(path)

generations = int(input("Enter number of generations: "))

# --- Evolution Loop ---
for g in range(generations):
    print(f"\n=== Generation {g+1} ===")
    print("Population:", population)

    # Crossover
    children = []
    for i in range(0, pop_size, 2):
        p1, p2 = population[i], population[i+1]
        c = crossover(p1, p2, 1, n//2)  # fixed crossover section
        d = crossover(p2, p1, 1, n//2)
        children.extend([c, d])
    print("After Crossover:", children)

    # Mutation
    mutated = []
    for path in children:
        i, j = random.sample(range(n), 2)
        mutated.append(mutate(path, i, j))
    population = mutated
    print("After Mutation:", population)

    # Fitness display
    for path in population:
        dist = -fitness(path, dist_matrix)  # convert back to distance
        print(path, "| Distance =", dist)

# --- Best Solution ---
best = max(population, key=lambda p: fitness(p, dist_matrix))
print("\nBest Path:", best, "| Distance:", -fitness(best, dist_matrix))
4

