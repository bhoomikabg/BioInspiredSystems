import random

# --- Fitness (shorter distance = better) ---
def fitness(route, dmat):
    dist = sum(dmat[route[i]][route[(i+1)%len(route)]] for i in range(len(route)))
    return -dist   # negative for maximization

# --- Order Crossover ---
def crossover(p1, p2, a, b):
    n=len(p1); child=[None]*n
    child[a:b]=p1[a:b]
    pos=b
    for c in p2:
        if c not in child:
            if pos==n: pos=0
            child[pos]=c; pos+=1
    return child

# --- Swap Mutation ---
def mutate(r, i, j):
    r=r[:]; r[i],r[j]=r[j],r[i]; return r

# --- Main ---
n=int(input("Enter number of cities: "))
print("Enter distance matrix:")
dmat=[list(map(int,input().split())) for _ in range(n)]

pop_size=int(input("Enter population size: "))
population=[list(map(int,input(f"Enter path {i+1} (space separated cities): ").split())) 
            for i in range(pop_size)]

generations=int(input("Enter number of generations: "))

for g in range(generations):
    print(f"\n=== Generation {g+1} ===")
    print("Population:", population)

    # Crossover (pairwise, fixed slice 1:n//2 for demo)
    children=[]
    for i in range(0,pop_size,2):
        p1,p2=population[i],population[i+1]
        c1=crossover(p1,p2,1,n//2)
        c2=crossover(p2,p1,1,n//2)
        children.extend([c1,c2])
    print("After Crossover:", children)

    # Mutation (swap two cities)
    mutated=[]
    for path in children:
        i,j=random.sample(range(n),2)
        mutated.append(mutate(path,i,j))
    population=mutated
    print("After Mutation:", population)

    # Fitness display
    for path in population:
        print(path,"| Distance=",-fitness(path,dmat))

# --- Best Solution ---
best=max(population,key=lambda r: fitness(r,dmat))
print("\nBest Path:",best,"| Distance=",-fitness(best,dmat))
